/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/


#include <stdio.h>

/* Xilinx includes. */
#include "xil_printf.h"
#include "xparameters.h"
/*user includes*/
#include "xil_mmu.h"
#include "Amplifier_Switch.h"
#include "ADDA.h"
#include "Communications_Protocol.h"
#include "Msg_que.h"
#include "My_kissFft.h"
#include "xgpiops.h" //包含 PS GPIO 的函数

#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
#define MIO_USB 8 //连接到 MIO8
int main()
{
	xil_printf("CPU1: initializing\r\n");
	/************************** USB初始化 *****************************/
	XGpioPs Gpio; // GPIO 设备的驱动程序实例
	XGpioPs_Config *ConfigPtr;
	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
	XGpioPs_CfgInitialize(&Gpio, ConfigPtr,ConfigPtr->BaseAddr);
	XGpioPs_SetDirectionPin(&Gpio, MIO_USB, 1);
	XGpioPs_SetOutputEnablePin(&Gpio, MIO_USB, 1);
	XGpioPs_WritePin(&Gpio, MIO_USB, 0x1);


	sleep(17);				//必须要有等待linux启动


	/************************** DMA初始化 *****************************/
	int status;
	XAxiDma_Config *config;
	config = XAxiDma_LookupConfig(DMA_DEV_ID);
	if (!config) {
	    xil_printf("No config found for %d\r\n", DMA_DEV_ID);
	}
	//初始化DMA引擎
	status = XAxiDma_CfgInitialize(&axidma, config);
	if (status != XST_SUCCESS) {
	    xil_printf("Initialization failed %d\r\n", status);
	}
    //初始化dma标志信号
    tx_done = 0;
    error   = 0;

	/************************** 定时器初始化 *****************************/
	status = timer_init(&Timer);     								//定时器初始化
	if (status != XST_SUCCESS) {
		xil_printf("Timer Initial Failed\r\n");
	}
	Timer_Flag = 0;

	//建立中断系统
	status = setup_intr_system(&intc, &axidma, &Timer,
			DMA_RX_INTR_ID, ADCS_RX_INTR_ID,DMA_TX_INTR_ID, Overflow_INTR_ID, Underflow_INTR_ID, Switch_INT_ID, Amplifier_INT_ID, SOFT_INTR_ID_TO_CPU1,TIMER_IRPT_INTR);
	if (status != XST_SUCCESS) {
	    xil_printf("Failed intr setup\r\n");
	}



	/************************** 禁用Cache*****************************/
	Xil_SetTlbAttributes(JSON_ADDR,0x14de2);    					//禁用Cache属性	//S=b1 TEX=b100 AP=b11, Domain=b1111, C=b0, B=b0
	Xil_SetTlbAttributes(UDP_ADDRESS,0x14de2);
	Xil_SetTlbAttributes(Share_addr,0x14de2);

	XScuTimer_Start(&Timer);         								//启动定时器
	InitializeQueues();
	init_JsonUdp();
	xil_printf("CPU1: Initialization successfully\r\n");



	/************************** 测试FFT*****************************/
	numHarmonics[0] = 6;
	harmonics[0][0] = 0.0;
	harmonics[0][1] = 0.0;
	harmonics[0][2] = 0.0;
	harmonics[0][3] = 0.0;
	harmonics[0][4] = 0.0;
	harmonics[0][5] = 0.0;

	numHarmonics[1] = 6;
	harmonics[1][0] = 0.0;
	harmonics[1][1] = 0.0;
	harmonics[1][2] = 0.0;
	harmonics[1][3] = 0.0;
	harmonics[1][4] = 0.0;
	harmonics[1][5] = 0.0;
	//生成交流信号
	str_wr_bram();
	//控制二级DA
	power_amplifier_control(Wave_Amplitude,Wave_Range);

	for (int i = 0; i < 8; i++)
	{
		setACS.Vals[i].U = 6.5;
		setACS.Vals[i].UR = 6.5; // 测试 设置电压幅值的初始值
		setACS.Vals[i].I_ = 5;	 // 测试 设置电流幅值的初始值
		setACS.Vals[i].IR = 5;	 // 测试 设置电流幅值的初始值
	}

    /************************** 测试FFT*****************************/

	while(1){
 		if(Timer_Flag){					//0.5S定时器

			/************************** 测试FFT*****************************/
 		    //开启AD
 			ADC_ChannelEnable = 1;
 			//开启ADC
 			adc_start();
 			sleep(1);

			Xil_DCacheFlushRange((UINTPTR) Share_addr, sample_points* 16 * CHANNL_MAX * AD_SAMP_CYCLE_NUMBER);
			for(int i = 0;i < 4;i++){
				// 分析FFT
				double harmonic_info_U[HarmNumberMax][3] = {0};
				double harmonic_info_I[HarmNumberMax][3] = {0};
				AnalyzeWaveform(harmonic_info_U, i);
				AnalyzeWaveform(harmonic_info_I, i + 5);

				//lineAC
		        lineAC.u[i] = (harmonic_info_U[0][1] / AD_UA_Correct) * setACS.Vals[0].UR;
		        lineAC.i[i] = (harmonic_info_I[0][1] / AD_IA_Correct) * setACS.Vals[0].IR;
		        lineAC.phu[i] = harmonic_info_U[0][2];
		        lineAC.phu[i] -= lineAC.phu[0];
		        lineAC.phi[i] = harmonic_info_I[0][2];
		        lineAC.phi[i] -= lineAC.phu[0];
		        lineAC.f[i] = harmonic_info_U[0][0];

		        //lineHarm
		        for (int j = 0; j < HarmNumberMax; j++) {
		            lineHarm.harm[i].u[j] = (harmonic_info_U[j][1]/ AD_UA_Correct) * setACS.Vals[0].UR;
		            lineHarm.harm[i].i[j] = (harmonic_info_I[j][1]/ AD_IA_Correct) * setACS.Vals[0].IR;
		            lineHarm.harm[i].phu[j] = harmonic_info_U[j][2];
		            lineHarm.harm[i].phi[j] = harmonic_info_I[j][2] ;
		        }


				// 打印结果
				printf("True IA= %.4f || ", lineAC.i[0]);
				printf("IB= %.4f || ", lineAC.i[1]);
				printf("IC= %.4f || ", lineAC.i[2]);
				printf("IX= %.4f\r\n", lineAC.i[3]);
			}
			/************************** 测试FFT*****************************/
			/*2 回报UDP结构体*/
			Timer_Flag = 0;
			ReportUDP_Structure(reportStatus);
//			printf("UA=%.4f\n",lineAC.u[0]);
//			str_wr_bram();
		}
	}
}
