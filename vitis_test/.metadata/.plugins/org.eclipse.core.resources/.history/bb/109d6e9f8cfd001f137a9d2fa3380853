/******************************************************************************
 *
 * Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * Use of the Software is limited solely to applications:
 * (a) running on a Xilinx device, or
 * (b) that interact with a Xilinx device through a bus or interconnect.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Xilinx shall not be used
 * in advertising or otherwise to promote the sale, use or other dealings in
 * this Software without prior written authorization from Xilinx.
 *
 ******************************************************************************/

#include <stdio.h>

/* Xilinx includes. */
#include "xil_printf.h"
#include "xparameters.h"
/*user includes*/
#include "xil_mmu.h"
#include "Amplifier_Switch.h"
#include "ADDA.h"
#include "Communications_Protocol.h"
#include "PID.h"
#include "Msg_que.h"
#include "My_kissFft.h"
#include "xgpiops.h" //包含 PS GPIO 的函数

#define GPIO_DEVICE_ID XPAR_XGPIOPS_0_DEVICE_ID
#define MIO_USB 8 // 连接到 MIO8
int main()
{
	xil_printf("CPU1: initializing\r\n");
	/************************** USB初始化 *****************************/
	XGpioPs Gpio; // GPIO 设备的驱动程序实例
	XGpioPs_Config *ConfigPtr;
	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
	XGpioPs_CfgInitialize(&Gpio, ConfigPtr, ConfigPtr->BaseAddr);
	XGpioPs_SetDirectionPin(&Gpio, MIO_USB, 1);
	XGpioPs_SetOutputEnablePin(&Gpio, MIO_USB, 1);
	XGpioPs_WritePin(&Gpio, MIO_USB, 0x1);

//	sleep(17); // 必须要有等待linux启动

	/************************** DMA初始化 *****************************/
	int status;
	XAxiDma_Config *config;
	config = XAxiDma_LookupConfig(DMA_DEV_ID);
	if (!config)
	{
		xil_printf("No config found for %d\r\n", DMA_DEV_ID);
	}
	// 初始化DMA引擎
	status = XAxiDma_CfgInitialize(&axidma, config);
	if (status != XST_SUCCESS)
	{
		xil_printf("Initialization failed %d\r\n", status);
	}
	// 初始化dma标志信号
	tx_done = 0;
	error = 0;

	/************************** 定时器初始化 *****************************/
	status = timer_init(&Timer); // 定时器初始化
	if (status != XST_SUCCESS)
	{
		xil_printf("Timer Initial Failed\r\n");
	}
	Timer_Flag = 0;

	// 建立中断系统
	status = setup_intr_system(&intc, &axidma, &Timer,
							   DMA_RX_INTR_ID, ADCS_RX_INTR_ID, DMA_TX_INTR_ID, Overflow_INTR_ID, Underflow_INTR_ID, Switch_INT_ID, Amplifier_INT_ID, SOFT_INTR_ID_TO_CPU1, TIMER_IRPT_INTR);
	if (status != XST_SUCCESS)
	{
		xil_printf("Failed intr setup\r\n");
	}

	/************************** 禁用Cache*****************************/
	Xil_SetTlbAttributes(JSON_ADDR, 0x14de2); // 禁用Cache属性	//S=b1 TEX=b100 AP=b11, Domain=b1111, C=b0, B=b0
	Xil_SetTlbAttributes(UDP_ADDRESS, 0x14de2);
	Xil_SetTlbAttributes(Share_addr, 0x14de2);
	Xil_SetTlbAttributes(Share_addr_2, 0x14de2);

	XScuTimer_Start(&Timer); // 启动定时器
	InitializeQueues();
	init_JsonUdp();
	PID_Init_All();
	xil_printf("CPU1: Initialization successfully\r\n");

	/************************** 测试FFT*****************************/
	numHarmonics[0] = 6;
	harmonics[0][0] = 0.0;
	harmonics[0][1] = 0.0;
	harmonics[0][2] = 0.0;
	harmonics[0][3] = 0.0;
	harmonics[0][4] = 0.0;
	harmonics[0][5] = 0.0;

	numHarmonics[4] = 6;
	harmonics[4][0] = 0.0;
	harmonics[4][1] = 0.0;
	harmonics[4][2] = 0.0;
	harmonics[4][3] = 0.0;
	harmonics[4][4] = 0.0;
	harmonics[4][5] = 0.0;
	// 生成交流信号
	str_wr_bram(PID_OFF);

	// 控制二级DA
	power_amplifier_control(Wave_Amplitude, Wave_Range, PID_OFF);

	for (int i = 0; i < 8; i++)
	{
		setACS.Vals[i].U = 6.5;
		setACS.Vals[i].UR = 6.5; // 测试 设置电压幅值的初始值
		setACS.Vals[i].I_ = 5;	 // 测试 设置电流幅值的初始值
		setACS.Vals[i].IR = 5;	 // 测试 设置电流幅值的初始值
	}

	/************************** 测试FFT*****************************/
	//内存测试
	printf("Share_addr_1: 0x%08X\n", Share_addr_1);
	printf("Share_addr_2: 0x%08X\n", Share_addr_2);
	printf("UDP_ADDRESS: 0x%08X\n", UDP_ADDRESS);
	printf("ADC data size: %d bytes\n", sample_points * 16 * CHANNL_MAX * AD_SAMP_CYCLE_NUMBER);

	// 开启第一次AD
	ADC_ChannelEnable = 1;
	AdcFinish_Flag = 0;
	adc_start(sample_points, sample_points * Wave_Frequency); // 设置每个周期的采样点数和采样频率

	while (1)
	{
		if (Timer_Flag)
		{

			/************************** 测试FFT*****************************/
			while (AdcFinish_Flag == 0); // 等待16个周期的ADC采样完成
//			usleep(400000);
			// 确定用于FFT计算的DDR区域 - 使用与当前ADC写入相反的区域
			u32 fft_share_addr = (Current_DDR_Region == 0) ? Share_addr_2 : Share_addr_1;
			// 刷新共享内存的缓存，保证数据的一致性
			Xil_DCacheFlushRange((UINTPTR)fft_share_addr, sample_points * 16 * CHANNL_MAX * AD_SAMP_CYCLE_NUMBER);

			// 开启下一次AD采样
			ADC_ChannelEnable = 1;
			AdcFinish_Flag = 0;
			adc_start(sample_points, sample_points * Wave_Frequency); // 设置每个周期的采样点数和采样频率

			double Phase_reference = 0; // 定义相位基准
			// 重置计算值
			lineAC.totalP = 0.0;
			lineAC.totalQ = 0.0;
			lineAC.totalPF = 0.0;
			for (int i = 0; i < 4; i++)
			{
				// 分析FFT
				double harmonic_info_U[HarmNumberMax][3] = {0}; // 创建用于存储谐波的数组
				double harmonic_info_I[HarmNumberMax][3] = {0};

				//				AnalyzeWaveform(harmonic_info_U, i);	//分析谐波 交流表
				//				AnalyzeWaveform(harmonic_info_I, i + 5);

				// 使用两块DDR地址交替进行FFT分析
				AnalyzeWaveform_WithDDR(harmonic_info_U, i, fft_share_addr, sample_points * Wave_Frequency, Wave_Frequency);
				AnalyzeWaveform_WithDDR(harmonic_info_I, i + 4, fft_share_addr, sample_points * Wave_Frequency, Wave_Frequency);

				if (i == 0)
				{
					// 定义相位基准
					Phase_reference = harmonic_info_U[0][2];
				}
				// lineAC - 将分析后的结果填充到UDP结构体里
				// 获取电压和电流量程索引
				int idx_u = get_voltage_index_by_value(setACS.Vals[i].UR);
				int idx_i = get_current_index_by_value(setACS.Vals[i].IR);

				lineAC.f[i] = harmonic_info_U[0][0];												  // 频率
				lineAC.ur[i] = setACS.Vals[0].UR;													  // 电压档位
				lineAC.u[i] = (harmonic_info_U[0][1] / AD_Correct[i][idx_u]) * setACS.Vals[i].UR;	  // 电压幅值 V
				lineAC.ir[i] = setACS.Vals[0].IR;													  // 电流档位
				lineAC.i[i] = (harmonic_info_I[0][1] / AD_Correct[i + 4][idx_i]) * setACS.Vals[i].IR; // 电流 A
				lineAC.phu[i] = harmonic_info_U[0][2] - Phase_reference;							  // 电压相位 角度制（UA为参考）
				if (lineAC.phu[i] < 0)
				{
					lineAC.phu[i] += 360;
				}
				lineAC.phi[i] = harmonic_info_I[0][2] - Phase_reference; // 电流相位（UA为参考）
				if (lineAC.phi[i] < 0)
				{
					lineAC.phi[i] += 360;
				}
				lineAC.p[i] = (lineAC.u[i] * lineAC.i[i] * cos(lineAC.phi[i] * M_PI / 180.0f)); // 有功功率
				lineAC.q[i] = (lineAC.u[i] * lineAC.i[i] * sin(lineAC.phi[i] * M_PI / 180.0f)); // 无功功率
				lineAC.pf[i] = cos(lineAC.phi[i] * M_PI / 180.0f);								// 功率因数

				// 累加到总功率
				lineAC.totalP += lineAC.p[i];
				lineAC.totalQ += lineAC.q[i];

				// 初始化总谐波畸变率变量
				double thdu = 0.0;
				double thdi = 0.0;
				// 计算电压总谐波畸变率 (THDU)
				if (harmonic_info_U[0][1] >= 0.0001)
				{ // 避免除以零
					double sum_of_squares_u = 0.0;
					// 遍历从2次谐波到32次谐波
					for (int h = 1; h < 32; h++)
					{
						// 计算第i次谐波的比值
						double harmonic_ratio_u = harmonic_info_U[h][1] / harmonic_info_U[0][1];
						// 累加平方
						sum_of_squares_u += harmonic_ratio_u * harmonic_ratio_u;
					}
					// 计算平方和的平方根，得到THD
					thdu = sqrt(sum_of_squares_u);
				}
				else
				{
					// 基波幅值为零，无法计算THD，可能需要处理这种特殊情况
					thdu = 0.0;
				}
				// 计算电流总谐波畸变率 (THDI)
				if (harmonic_info_I[0][1] >= 0.0001)
				{ // 避免除以零
					double sum_of_squares_i = 0.0;
					// 遍历从2次谐波到32次谐波
					for (int h = 1; h < 32; h++)
					{
						// 计算第i次谐波的比值
						double harmonic_ratio_i = harmonic_info_I[h][1] / harmonic_info_I[0][1];
						// 累加平方
						sum_of_squares_i += harmonic_ratio_i * harmonic_ratio_i;
					}
					// 计算平方和的平方根，得到THD
					thdi = sqrt(sum_of_squares_i);
				}
				else
				{
					// 基波幅值为零，无法计算THD，可能需要处理这种特殊情况
					thdi = 0.0;
				}
				// 保存结果
				lineAC.thdu[i] = thdu * 100.0;
				lineAC.thdi[i] = thdi * 100.0;

				// lineHarm
				for (int j = 0; j < HarmNumberMax; j++)
				{
					lineHarm.harm[i].u[j] = (harmonic_info_U[j][1] / AD_UA_Correct) * setACS.Vals[0].UR;
					lineHarm.harm[i].i[j] = (harmonic_info_I[j][1] / AD_IA_Correct) * setACS.Vals[0].IR;
					lineHarm.harm[i].phu[j] = harmonic_info_U[j][2];
					lineHarm.harm[i].phi[j] = harmonic_info_I[j][2];
				}
			}
			// 总功率因数
			double totalApparentPower = sqrt(lineAC.totalP * lineAC.totalP + lineAC.totalQ * lineAC.totalQ);
			if (totalApparentPower > 0)
			{
				lineAC.totalPF = lineAC.totalP / totalApparentPower;
			}
			else
			{
				lineAC.totalPF = 0.0; // 避免除以零错误，设置功率因数为0
			}
			/************************** 测试FFT*****************************/

			/*2 回报UDP结构体*/
			__sync_synchronize(); // Memory barrier
			Timer_Flag = 0;
			ReportUDP_Structure(reportStatus);

			/*3 PID闭环调整输出*/
			// 生成交流信号
			str_wr_bram(PID_OFF);
			// 调试
			//  printf("PhIB=%.4f\r\n", lineAC.phi[1]);
			//  printf("SetB=%.4f\r\n", 150.00);
			//  控制二级DA
			printf("True UA= %.4f || ", lineAC.u[0]);
			printf("UB= %.4f || ", lineAC.u[1]);
			printf("UC= %.4f || ", lineAC.u[2]);
			printf("UX= %.4f\r\n", lineAC.u[3]);
			printf("SET  UA= %.4f\r\n", lineAC.ur[0] * Wave_Amplitude[0] / 100);

			printf("True IA= %.4f || ", lineAC.i[0]);
			printf("IB= %.4f || ", lineAC.i[1]);
			printf("IC= %.4f || ", lineAC.i[2]);
			printf("IX= %.4f\r\n", lineAC.i[3]);
			printf("SET  IA= %.4f\r\n\r\n", lineAC.ir[0] * Wave_Amplitude[4] / 100);

			// 修改二级DA 波形幅度 量程
			for (int i = 0; i < 4; i++)
			{
				Wave_Amplitude[i] = (float)(setACS.Vals[i].U / setACS.Vals[i].UR) * 100;
				Wave_Amplitude[i + 4] = (float)(setACS.Vals[i].I_ / setACS.Vals[i].IR) * 100;
				Wave_Range[i] = voltage_to_output(setACS.Vals[i].UR);
				Wave_Range[i + 4] = current_to_output(setACS.Vals[i].IR);
				//		printf(" Wave_Amplitude_U=%f\n Wave_Amplitude_I=%f\n Wave_Range_U=%lu\n Wave_Range_I=%lu\n",Wave_Amplitude[i] , Wave_Amplitude[i+4] , Wave_Range[i] , Wave_Range[i+4]);
			}
			power_amplifier_control(Wave_Amplitude, Wave_Range, PID_OFF);
		}
	}
}
