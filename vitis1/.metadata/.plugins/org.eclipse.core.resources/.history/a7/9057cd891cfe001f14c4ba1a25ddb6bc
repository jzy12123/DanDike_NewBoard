#include "ADDA.h"
/*
 * 变量
 */
XAxiDma axidma;                     // XAxiDma实例
XScuGic intc;                       // 中断控制器的实例
XScuTimer Timer;                    // 定时器驱动程序实例
volatile int tx_done;               // 发送完成标志
volatile int error;                 // 传输出错标志
volatile int adcS_done;             // adc发送完成标志
volatile u8 Timer_Flag;             // 定时器完成标志
volatile u8 Current_DDR_Region = 0; // 0表示使用Share_addr_1，1表示使用Share_addr_2

// ad
int dma_rx_8[8][sample_points] = {0}; // 8个通道，每个通道的采样点数sample_points
u16 *rx_buffer_ptr = (u16 *)RX_BUFFER_BASE;
u16 *tx_buffer_ptr = (u16 *)TX_BUFFER_BASE;
u8 ADC_ChannelEnable = 0;

// 波形修改参数
float Phase_shift[8] = {0, 30, 60, 90, 120, 150, 180, 210}; // 8路波形相位偏移 单位度
u32 enable = 0xff;                                          // 使能通道输出
float Wave_Frequency = 50;
float Wave_Amplitude[8] = {100, 100, 100, 100, 100, 100, 100, 100};
u32 Wave_Range[8] = {0xC2, 0xC2, 0xC2, 0xC2, 0x92, 0x92, 0x92, 0x92};
uint16_t Wave_NewData[8][DATA_LEN]; // 修改后8路通道所有数据

int numHarmonics[CHANNL_MAX] = {0};                      // 每个通道有几个谐波
float harmonics[CHANNL_MAX][MAX_HARMONICS] = {0};        // 每个通道每次谐波的幅值
float harmonics_phases[CHANNL_MAX][MAX_HARMONICS] = {0}; // 每个通道每次谐波的相位

// 功放输出参数
double DA_Correct[8][3] = {
    // Voltage channels (UA, UB, UC, UX) - for 6.5V, 3.25V, 1.876V
    {35743.744844, 35688.838937, 38472.249867}, // UA 111
    {35820.831873, 35754.250401, 38507.972835}, // UB 111
    {35743.744844, 35699.823498, 38492.768400}, // UC 111
    {35743.744844, 35699.823498, 38472.249867}, // UX 000

    // Current channels (IA, IB, IC, IX) - for 5A, 1A, 0.2A
    {35471.388977, 41083.116459, 41370.352427}, // IA 111
    {35451.349561, 41026.379569, 41089.986359}, // IB 111
    {35455.531774, 41026.379569, 41164.529778}, // IC 111
    {35462.627137, 41026.379569, 40960.744977}  // IX 111
};

// AD校准参数数组
double AD_Correct[8][3] = {
    // 电压通道 (UA, UB, UC, UX) - 分别对应 6.5V, 3.25V, 1.876V
    {41316586.551776, 41283651.847470, 44599078.747599}, // UA 111
    {41368733.166927, 41323447.948506, 44596711.040431}, // UB 111
    {41282965.707797, 41249344.863818, 44584391.850804}, // UC 111
    {41282965.707797, 41249344.863818, 44560638.845023}, // UX 000

    // 电流通道 (IA, IB, IC, IX) - 分别对应 5A, 1A, 0.2A
    {41022236.685124, 47617235.829736, 47928772.853282}, // IA 111
    {41054828.250664, 47617235.829736, 47665164.602589}, // IB 111
    {41016589.525392, 47564514.179597, 47712973.553510}, // IC 111
    {41012320.605451, 47550135.547741, 47449485.124749}  // IX 111
};

/*
 * 函数输入为采样频率
 * 自动设置IP核的采样点和采样频率
 */
void adc_start(int SamplePoints, int SampleFrequency)
{

    if (sample_points == 256)
    {
        Xil_Out32(adc_whole_base_addr + 8, SamplePoints);               // 采样点：sample_points写1024
        Xil_Out32(adc_whole_base_addr + 4, 99993600 / SampleFrequency); // 7812，对应采样频率50*256
    }

    Xil_Out32(adc_whole_base_addr + 0, 0); // 开启一次ADC
    Xil_Out32(adc_whole_base_addr + 0, 1);
    // 接下来进入adcS_intr_handler中断函数
}

void dma_dac_init()
{
    // dma_dac
    start_dma_dac();
}

void dds_dac_init()
{

    // 更改使能、频率、相位、通道使能
    str_wr_bram(PID_OFF);
}

// DMA RX中断处理函数 adc
void rx_intr_handler(void *callback)
{
    // 进入到该中断函数中代表DMA已经完成了一次传输
    u32 irq_status;
    int timeout;
    XAxiDma *axidma_inst = (XAxiDma *)callback;

    irq_status = XAxiDma_IntrGetIrq(axidma_inst, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrAckIrq(axidma_inst, irq_status, XAXIDMA_DEVICE_TO_DMA);

    // Rx出错
    if ((irq_status & XAXIDMA_IRQ_ERROR_MASK))
    {
        error = 1;
        XAxiDma_Reset(axidma_inst);
        timeout = RESET_TIMEOUT_COUNTER;
        while (timeout)
        {
            if (XAxiDma_ResetIsDone(axidma_inst))
                break;
            timeout -= 1;
        }
        return;
    }

    // Rx完成
    if ((irq_status & XAXIDMA_IRQ_IOC_MASK))
    {
        // 用户函数
        Xil_DCacheFlushRange((UINTPTR)rx_buffer_ptr, sample_points * 16 * CHANNL_MAX);
        Adc_Data_processing();
    }
}

void adcS_intr_handler(void *callback)
{
    // 进入到此中断代表ADC已经完成了一次采样任务（1024个点 或 2048个点）
    // 继续开启新一次的ADC
//	printf("ADC_Handler\r\n");
    if (ADC_ChannelEnable)
    { // ADC_ChannelEnable不为0，则开启ADC
        adc_start(sample_points, sample_points * Wave_Frequency);
    }
    // 同时开启DMA传输上一次的ADC结果到DDR rx_buffer_ptr
    // sample_points个点 *16位*8个通道
    XAxiDma_SimpleTransfer(&axidma, (UINTPTR)rx_buffer_ptr, sample_points * 16 * CHANNL_MAX, XAXIDMA_DEVICE_TO_DMA);
    // 接下来进入rx_intr_handler函数
}

// DMA TX中断处理函数 dac
void tx_intr_handler(void *callback)
{
    int timeout;
    u32 irq_status;
    XAxiDma *axidma_inst = (XAxiDma *)callback;

    // 读取待处理的中断
    irq_status = XAxiDma_IntrGetIrq(axidma_inst, XAXIDMA_DMA_TO_DEVICE);
    // 确认待处理的中断
    XAxiDma_IntrAckIrq(axidma_inst, irq_status, XAXIDMA_DMA_TO_DEVICE);

    // Tx出错
    if ((irq_status & XAXIDMA_IRQ_ERROR_MASK))
    {
        error = 1;
        XAxiDma_Reset(axidma_inst);
        timeout = RESET_TIMEOUT_COUNTER;
        while (timeout)
        {
            if (XAxiDma_ResetIsDone(axidma_inst))
                break;
            timeout -= 1;
        }
        return;
    }

    // Tx完成
    if ((irq_status & XAXIDMA_IRQ_IOC_MASK))
    {
        tx_done = 1;
    }
}

// 上溢：写满fifo后继续写则导致上溢
void overflow_handler()
{
    // xil_printf("overflow\r\n");
}

// 下溢：读空fifo后继续读则导致下溢
void underflow_handler()
{
    // xil_printf("underflow\r\n");

    //	Copy_Wave_to_tx_buffer_ptr();
    Xil_DCacheFlushRange((UINTPTR)tx_buffer_ptr, DATA_LEN * 16); // 刷新Data Cache
    XAxiDma_SimpleTransfer(&axidma, (UINTPTR)tx_buffer_ptr, DATA_LEN * 16, XAXIDMA_DMA_TO_DEVICE);
}

// 软件中断函数
void soft_intr_handler()
{
    xil_printf("CPU1: CPU1 Soft Interrupt\r\n");
}

// 定时器中断处理函数
void timer_intr_handler(void *CallBackRef)
{
    XScuTimer *timer_ptr = (XScuTimer *)CallBackRef;
    Timer_Flag = 1;

    /*1 消息队列*/
    // 读取消息队列
    char buffer[MAX_DATA_LEN];
    ssize_t bytesRead = MsgQue_read(buffer, sizeof(buffer));
    if (bytesRead > 0)
    {
        // 解析JSON指令
        Parse_JsonCommand(buffer);
    }

    // 清除定时器中断标志
    XScuTimer_ClearInterruptStatus(timer_ptr);
}

// 定时器初始化程序
int timer_init(XScuTimer *timer_ptr)
{
    int status;
    // 私有定时器初始化
    XScuTimer_Config *timer_cfg_ptr;
    timer_cfg_ptr = XScuTimer_LookupConfig(TIMER_DEVICE_ID);
    if (NULL == timer_cfg_ptr)
        return XST_FAILURE;
    status = XScuTimer_CfgInitialize(timer_ptr, timer_cfg_ptr, timer_cfg_ptr->BaseAddr);
    if (status != XST_SUCCESS)
        return XST_FAILURE;

    XScuTimer_LoadTimer(timer_ptr, TIMER_LOAD_VALUE); // 加载计数周期
    XScuTimer_EnableAutoReload(timer_ptr);            // 设置自动装载模式

    return XST_SUCCESS;
}

// 建立DMA中断系统
//   @param   int_ins_ptr是指向XScuGic实例的指针
//   @param   AxiDmaPtr是指向DMA引擎实例的指针
//   @param   tx_intr_id是TX通道中断ID
//   @param   rx_intr_id是RX通道中断ID
//   @return：成功返回XST_SUCCESS，否则返回XST_FAILURE
int setup_intr_system(XScuGic *int_ins_ptr, XAxiDma *axidma_ptr, XScuTimer *timer_ptr,
                      u16 rx_intr_id, u16 adcS_id, u16 tx_intr_id, u16 overflow_id, u16 underflow_id, u16 switch_id, u16 amplifier_id, u16 SoftIntrCpu1_id, u16 Timer_id)
{
    int status;
    XScuGic_Config *intc_config;

    // 初始化中断控制器驱动
    intc_config = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == intc_config)
    {
        return XST_FAILURE;
    }
    status = XScuGic_CfgInitialize(int_ins_ptr, intc_config,
                                   intc_config->CpuBaseAddress);
    if (status != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    // 设置优先级和触发类型
    // ad
    XScuGic_SetPriorityTriggerType(int_ins_ptr, rx_intr_id, 0xA0, 0x3);
    XScuGic_SetPriorityTriggerType(int_ins_ptr, adcS_id, 0xA0, 0x03);
    // da
    XScuGic_SetPriorityTriggerType(int_ins_ptr, tx_intr_id, 0xA0, 0x3);
    XScuGic_SetPriorityTriggerType(int_ins_ptr, overflow_id, 0xA0, 0x3); // 高电平有效
    XScuGic_SetPriorityTriggerType(int_ins_ptr, underflow_id, 0xA0, 0x3);
    // switch amp
    XScuGic_SetPriorityTriggerType(int_ins_ptr, switch_id, 0xA0, 0x3);
    XScuGic_SetPriorityTriggerType(int_ins_ptr, amplifier_id, 0xA0, 0x3); // 高电平有效
    // 为定时器中断设置较高优先级
    XScuGic_SetPriorityTriggerType(int_ins_ptr, Timer_id, 0x20, 0x3); // 设置更高优先级

    // 为中断设置中断处理函数
    XScuGic_Connect(int_ins_ptr, rx_intr_id, (Xil_InterruptHandler)rx_intr_handler, axidma_ptr);
    XScuGic_Connect(int_ins_ptr, adcS_id, (Xil_InterruptHandler)adcS_intr_handler, (void *)1);
    XScuGic_Connect(int_ins_ptr, tx_intr_id, (Xil_InterruptHandler)tx_intr_handler, axidma_ptr);
    XScuGic_Connect(int_ins_ptr, overflow_id, (Xil_InterruptHandler)overflow_handler, (void *)1);
    XScuGic_Connect(int_ins_ptr, underflow_id, (Xil_InterruptHandler)underflow_handler, (void *)1);
    XScuGic_Connect(int_ins_ptr, switch_id, (Xil_ExceptionHandler)Switch_INT_handler, (void *)1);
    XScuGic_Connect(int_ins_ptr, amplifier_id, (Xil_ExceptionHandler)Amplifier_INT_handler, (void *)1);
    XScuGic_Connect(int_ins_ptr, SoftIntrCpu1_id, (Xil_ExceptionHandler)soft_intr_handler, (void *)int_ins_ptr); // CPU1软中断
    XScuGic_Connect(int_ins_ptr, Timer_id, (Xil_ExceptionHandler)timer_intr_handler, (void *)timer_ptr);         // 定时器

    // 使能
    // ad
    XScuGic_Enable(int_ins_ptr, rx_intr_id);
    XScuGic_Enable(int_ins_ptr, adcS_id);
    // da
    XScuGic_Enable(int_ins_ptr, tx_intr_id);
    XScuGic_Enable(int_ins_ptr, overflow_id);
    XScuGic_Enable(int_ins_ptr, underflow_id);
    // switch amp
    XScuGic_Enable(int_ins_ptr, switch_id);
    XScuGic_Enable(int_ins_ptr, amplifier_id);
    // CPU1软中断
    XScuGic_Enable(int_ins_ptr, SoftIntrCpu1_id); // CPU1软件中断
    // 定时器
    XScuGic_Enable(int_ins_ptr, Timer_id);
    // 启用来自硬件的中断
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 (void *)int_ins_ptr);
    Xil_ExceptionEnable();

    // 使能中断
    XAxiDma_IntrEnable(&axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA); // DMA
    XAxiDma_IntrEnable(&axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);
    XScuTimer_EnableInterrupt(timer_ptr); // 定时器
    return XST_SUCCESS;
}

int code_to_real(u16 x)
{ // 将16位数据转换成实际电压值
    int x1 = 0;
    int x2 = 0;

    if ((x >> 15) == 0)
    { // 如果是正电压，最高位为0
        x2 = +((int)(x + 1));
        // x2 = +(((float)(x+1))*(20.0f))/(65536.0f);
    }
    else
    {                           // 如果是负电压
        x1 = 0xFFFF - x + 0x01; // 将16位二进制数据全部取反，再+1
        x2 = -((int)(x1));
        // x2 = -(((float)(x1))*(20.0f))/(65536.0f);
    }
    return x2;
}

bool AdcFinish_Flag = 0; // ADc完成标志，在中断处理函数中写1，主循环中读取

/**
 * @brief 处理ADC采集的数据
 *
 * 将采集到的ADC数据通过code_to_real函数转换，并将结果存储到dma_rx_8数组中。
 * 然后将处理后的数据写入共享DDR中，用于后续处理。
 *
 * @details
 * 1. 循环遍历每个采样点，将采集到的ADC数据通过code_to_real函数转换为实际值，并存储到dma_rx_8数组中。
 * 2. 将处理后的数据写入共享DDR中，每个通道的数据写入不同的地址。
 * 3. 更新ADC_Sampling_ddr计数器，用于控制写入DDR的次数。
 * 4. 当ADC_Sampling_ddr减到1时，关闭AD功能。
 * 5. 当ADC_Sampling_ddr减到0时，重置ADC_Sampling_ddr为AD_SAMP_CYCLE_NUMBER，并设置AdcFinish_Flag标志为1，表示ADC数据处理完成。
 */
void Adc_Data_processing()
{
    /************************** 数据处理 *****************************/
    int k = 0;
    // 确定当前写入的DDR区域
    u32 current_share_addr = (Current_DDR_Region == 0) ? Share_addr_1 : Share_addr_2;

    static int ADC_Sampling_ddr = AD_SAMP_CYCLE_NUMBER; // 向内存里写几个周期

    // 直接从rx_buffer_ptr处理数据并写入当前DDR区域
    for (int i = 0; i < sample_points; i++)
    {
        // 直接处理并写入DDR，跳过dma_rx_8数组
        Xil_Out32(current_share_addr + 0 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 1])); // JUA

        Xil_Out32(current_share_addr + 1 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 3])); // JUB

        Xil_Out32(current_share_addr + 2 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 5])); // JUC

        Xil_Out32(current_share_addr + 3 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 7])); // JUX

        Xil_Out32(current_share_addr + 4 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k])); // JIA

        Xil_Out32(current_share_addr + 5 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 2])); // JIB

        Xil_Out32(current_share_addr + 6 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 4])); // JIC

        Xil_Out32(current_share_addr + 7 * sample_points * 4 + (AD_SAMP_CYCLE_NUMBER - ADC_Sampling_ddr) * CHANNL_MAX * sample_points * 4 + i * 4,
                  (u32)code_to_real(rx_buffer_ptr[k + 6])); // JIX

        k += 8; // 移动到下一组数据
    }

    ADC_Sampling_ddr--;
    if (ADC_Sampling_ddr == 1)
    {
        ADC_ChannelEnable = 0; // 关闭AD功能
    }
    else if (ADC_Sampling_ddr == 0)
    {
        // 说明AD_SAMP_CYCLE_NUMBER写完了一轮
        ADC_Sampling_ddr = AD_SAMP_CYCLE_NUMBER;     // 循环写AD_SAMP_CYCLE_NUMBER个波形
        AdcFinish_Flag = 1;                          // 给ADc完成标志写1
        Current_DDR_Region = 1 - Current_DDR_Region; // 切换DDR区域(0->1或1->0)
    }
}

void changePhase(uint16_t NewData[], int Array_Length, float Phase_Degress)
{
    for (int i = 0; i < Array_Length; i++)
    {
        // 计算相位偏移后的正弦波值
        double phase = 2 * M_PI * i / Array_Length;                    // 角度值
        double shifted_phase = phase + (Phase_Degress * M_PI / 180.0); // 添加相位偏移
        double sin_value = sin(shifted_phase);                         // 计算正弦值
        // 将正弦值映射到合适的幅度范围（0到MAX_AMPLITUDE）
        NewData[i] = (uint16_t)((sin_value + 1.0) * 0.5 * Data_Width);
    }
}

void Write_Wave_to_Wave_NewData()
{
    // 二维数组8*DATA_LEN     Wave_NewData中存储的是8个通道，每个通道DATA_LEN个点，正弦波

    for (int i = 0; i < CHANNL_MAX; i++)
    {
        addHarmonics(Wave_NewData[i], DATA_LEN, Phase_shift[i], numHarmonics[i], harmonics[i], harmonics_phases[i]);
    }

    if (DATA_LEN == 2048)
    {
        // 8*1024改成8*2048
        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 1024; j++)
            {
                Wave_NewData[i][j + 1024] = Wave_NewData[i][j];
            }
        }
    }

    if (DATA_LEN == 4096)
    {
        // 8*1024改成8*2048
        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 1024; j++)
            {
                Wave_NewData[i][j + 1024] = Wave_NewData[i][j];
            }
        }

        // 8*2048改成8*4096
        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 2048; j++)
            {
                Wave_NewData[i][j + 2048] = Wave_NewData[i][j];
            }
        }
    }
}

void Copy_Wave_to_tx_buffer_ptr()
{
    // 要给一维数组tx_buffer_ptr赋值，tx_buffer_ptr中存的是8个通道的所有数据，正弦波。前8位分别对应8个通道的第一个点，依次类推，每个通道存DATA_LEN个点
    int k = 0;
    for (int j = 0; j < DATA_LEN; j++)
    {
        for (int i = 0; i < 8; i++)
        {
            tx_buffer_ptr[k + i] = Wave_NewData[i][j];
        }
        k += 8;
    }
}

void start_dma_dac()
{
    u16 frequency_divisor; // 分频系数 默认为1953
    // 修改通道使能和分频系数
    frequency_divisor = 100000000 / Wave_Frequency / DATA_LEN; // 分频系数

    /*
     * dma_enable     (slv_reg0[16])
     * dma_freq_div   (slv_reg1[31:16])
     * dma_channels   (slv_reg2[23:16])
     */
    Xil_Out32(dac_whole_base_addr + 0, (u32)0x10000);
    Xil_Out32(dac_whole_base_addr + 4, (u32)(frequency_divisor << 16));
    Xil_Out32(dac_whole_base_addr + 8, (u32)(enable) << 16);

    Write_Wave_to_Wave_NewData();
    Copy_Wave_to_tx_buffer_ptr();
    Xil_DCacheFlushRange((UINTPTR)tx_buffer_ptr, DATA_LEN * 16); // 刷新Data Cache
    XAxiDma_SimpleTransfer(&axidma, (UINTPTR)tx_buffer_ptr, DATA_LEN * 16, XAXIDMA_DMA_TO_DEVICE);
}

// 将波形写入BRAM
void str_wr_bram(PID_STATE pid_state)
{
    u32 data_2channl; // 32位数据，存放2个通道16位的波形
    u16 channel_cnt = 0;

    u16 frequency_divisor; // 分频系数 默认为1953
    // 修改波形

    // PID调整相位
    double Phase_PID_Increment[CHANNL_MAX] = {0};
    if (pid_state == PID_ON)
    {
        for (int i = 0; i < CHANNL_MAX; i++)
        {
            // 假设lineAC.phu和lineAC.phi存储的是对应通道的实际相位
            double actual_value = (i < 4) ? lineAC.phu[i] : lineAC.phi[i - 4]; // 根据通道选择实际值

            Phase_PID_Increment[i] = PID_adjust_phase(Phase_shift[i], actual_value, &phase_pid[i]);
        }
    }
    else
    {
        // 当PID调节关闭时，清空phase_pid的累计值
        for (int i = 0; i < CHANNL_MAX; i++)
        {
            Phase_PID_Increment[i] = 0; // 清空PID累计值
            phase_pid[i].integral = 0;
            phase_pid[i].prev_error = 0;
        }
    }

    for (int i = 0; i < CHANNL_MAX; i++)
    {
        addHarmonics(Wave_NewData[i], DATA_LEN, Phase_shift[i] + Phase_PID_Increment[i], numHarmonics[i], harmonics[i], harmonics_phases[i]);
    }

    // 修改通道使能和分频系数
    frequency_divisor = 100000000 / Wave_Frequency / DATA_LEN; // 分频系数
    /*
     *  dds_enable     (slv_reg0[0])
     *  dds_freq_div   (slv_reg1[15:0])    //1953
     *  dds_channels   (slv_reg2[7:0])
     */
    Xil_Out32(dac_whole_base_addr + 0, 1); // start_dds写1,第17位
    Xil_Out32(dac_whole_base_addr + 4, (u32)frequency_divisor);
    Xil_Out32(dac_whole_base_addr + 8, (u32)enable);

    // 写入BRAM
    // 最大地址为32bit*4 *1024 = 16KB
    for (int j = 0; j < DATA_LEN; j++)
    {
        for (int i = 0; i < 4 * BRAM_DATA_BYTE; i += BRAM_DATA_BYTE)
        { // 更新了8通道的第一个采样点
            data_2channl = (Wave_NewData[channel_cnt + 1][j] << 16) + Wave_NewData[channel_cnt][j];
            XBram_WriteReg(XPAR_BRAM_0_BASEADDR, i + j * 4 * BRAM_DATA_BYTE, data_2channl);
            channel_cnt += 2;
        }
        channel_cnt = 0;
    }
}

/*
 *    添加谐波
 */
void addHarmonics(uint16_t NewData[], int Array_length, float Base_Phase_Degrees, int numHarmonics, float harmonics[], float harmonics_phases[])
{
    // harmonics[0]为2次谐波
    for (int i = 0; i < Array_length; i++)
    {
        double phase = 2 * M_PI * i / Array_length;                         // 基本波形的相位
        double shifted_phase = phase + (Base_Phase_Degrees * M_PI / 180.0); // 添加基波相位偏移
        double sum = sin(shifted_phase);                                    // 基本正弦波

        // 添加谐波
        for (int j = 0; j < numHarmonics; j++)
        {
            double harmonic_phase = (j + 2) * phase;                                               // 基波的整数倍
            double shifted_harmonic_phase = harmonic_phase + (harmonics_phases[j]) * M_PI / 180.0; // 使用基波和谐波的相位偏移
            double harmonic_value = sin(shifted_harmonic_phase);

            sum += harmonic_value * harmonics[j]; // 添加谐波并乘以相应的幅值
        }

        // 归一化并转换为 uint16_t 类型
        NewData[i] = (uint16_t)((sum / (1.0 + sumHarmonics(harmonics, numHarmonics))) * 32768 + 32767);
    }
}

// 辅助函数，计算谐波幅值总和
double sumHarmonics(float harmonics[], int numHarmonics)
{
    double sum = 0.0;
    for (int i = 0; i < numHarmonics; i++)
    {
        sum += harmonics[i];
    }
    return sum;
}

/**
 * @brief 根据电压值获取电压等级索引
 *
 * 根据给定的电压值，返回对应的电压等级索引。
 *
 * @param voltage 电压值，单位为伏特（V）
 * @return 返回电压等级索引：
 *         - 0：表示电压值大于等于6.0V（对应6.5V）
 *         - 1：表示电压值大于等于3.0V且小于6.0V（对应3.25V）
 *         - 2：表示电压值小于3.0V（对应1.876V）
 */
int get_voltage_index_by_value(float voltage)
{
    if (voltage >= 6.0)
        return 0; // 6.5V
    else if (voltage >= 3.0)
        return 1; // 3.25V
    else
        return 2; // 1.876V
}

/**
 * @brief 根据电流值获取当前索引
 *
 * 根据给定的电流值（current），返回对应的索引值。
 *
 * @param current 电流值，类型为float
 * @return 返回对应的索引值，类型为int。如果电流值大于等于3.0，则返回0（表示5A）；
 *         如果电流值大于等于0.5但小于3.0，则返回1（表示1A）；
 *         如果电流值小于0.5，则返回2（表示0.2A）。
 */
int get_current_index_by_value(float current)
{
    if (current >= 3.0)
        return 0; // 5A
    else if (current >= 0.5)
        return 1; // 1A
    else
        return 2; // 0.2A
}
